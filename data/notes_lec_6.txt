RECURSION, DICTIONARIES (download slides and .py files and follow along!) 1 QUIZ PREP § a paper and an online component § open book/notes § not open Internet, not open computer § start prinSng out whatever you may want to bring 2 LAST TIME § tuples - immutable § lists - mutable § aliasing, cloning § mutability side effects 3 TODAY § recursion – divide/decrease and conquer § dicSonaries – another mutable object type 4 RECURSION Recursion is the process of repeaSng items in a self-s imilar way. 5 WHAT IS RECURSION? § Algorithmically: a way to design soluSons to problems by divide-and-conquer or decrease-and-conquer
reduce a problem to simpler versions of the same problem § SemanScally: a programming technique where a func0on calls itself
in programming, goal is to NOT have infinite recursion
must have 1 or more base cases that are easy to solve
must solve the same problem on some other input with the goal of simplifying the larger problem input 6 ITERATIVE ALGORITHMS SO FAR § looping constructs (while and for loops) lead to itera0ve algorithms § can capture computaSon in a set of state variables that update on each iteraSon through loop 7 MULTIPLICATION – ITERATIVE SOLUTION § “mulSply a * b” is equivalent to “add a to itself b Smes” a + a + a + a + … + a § capture state by
an itera0on number (i) starts at b i ß i-1 and stop when 0 0a 1a 2a 3a 4a
a current value of computa0on (result) result ß result + a def mult_iter(a, b): result = 0 while b > 0: result += a b -= 1 return result 8 MULTIPLICATION – RECURSIVE SOLUTION § recursive step a*b = a + a + a + a + … + a
think how to reduce problem to a simpler/ = a + a + a + a + … + a smaller version of same problem = a + a * (b-1) § base case
keep reducing def mult(a, b): problem unSl reach a if b == 1: simple case that can be solved directly return a
when b = 1, a*b = a else: return a + mult(a, b-1) 9 FACTORIAL n! = n*(n-1)*(n-2)*(n-3)* … * 1 § for what n do we know the factorial? n = 1 à if n == 1: return 1 § how to reduce problem? Rewrite in terms of something simpler to reach base case n*(n-1)! à else: return n*factorial(n-1) 10 def fact(n): RECURSIVE if n == 1: FUNCTION return 1 else: SCOPE return n*fact(n-1) EXAMPLE print(fact(4)) Global scope fact scope fact scope fact scope fact scope (call w/ n=4) (call w/ n=3) (call w/ n=2) (call w/ n=1) fact Some n n n n 4 3 2 1 code 11 SOME OBSERVATIONS § each recursive call to a funcSon creates its own scope/environment § bindings of variables in a scope are not changed by recursive call § flow of control passes back to previous scope once funcSon call returns value 12 ITERATION v s. RECURSION def factorial_iter(n): def factorial(n): prod = 1 if n == 1: for i in range(1,n+1): return 1 prod *= i else: return prod return n*factorial(n-1) § recursion may be simpler, more intuiSve § recursion may be efficient from programmer POV § recursion may not be efficient from computer POV 13 INDUCTIVE REASONING § How do we know that our def mult_iter(a, b): recursive code will work? result = 0 § mult_iter terminates while b > 0: because b is iniSally posiSve, result += a and decreases by 1 each Sme b -= 1 around loop; thus must eventually become less than 1 return result § mult called with b = 1 has no recursive call and stops def mult(a, b): § mult called with b > 1 makes if b == 1: a recursive call with a smaller return a version of b; must eventually reach call with b = 1 else: return a + mult(a, b-1) 14 MATHEMATICAL INDUCTION § To prove a statement indexed on integers is true for all values of n:
Prove it is true when n is smallest value (e.g. n = 0 or n = 1)
Then prove that if it is true for an arbitrary value of n, one can show that it must be true for n+1 15 EXAMPLE OF INDUCTION § 0 + 1 + 2 + 3 + … + n = (n(n+1))/2 § Proof:
If n = 0, then LHS is 0 and RHS is 0*1/2 = 0, so true
Assume true for some k, then need to show that 0 + 1 + 2 + … + k + (k+1) = ((k+1)(k+2))/2
LHS is k(k+1)/2 + (k+1) by assumpSon that property holds for problem of size k
This becomes, by algebra, ((k+1)(k+2))/2
Hence expression holds for all n >= 0 16 RELEVANCE TO CODE? § Same logic applies def mult(a, b): if b == 1: return a else: return a + mult(a, b-1) § Base case, we can show that mult must return correct answer § For recursive case, we can assume that mult correctly returns an answer for problems of size smaller than b, then by the addiSon step, it must also return a correct answer for problem of size b § Thus by inducSon, code correctly returns answer 17 TOWERS OF HANOI § The story:
3 tall spikes
Stack of 64 different sized discs – start on one spike
Need to move stack to second spike (at which point universe ends)
Can only move one disc at a Sme, and a larger disc can never cover up a small disc 18 TOWERS OF HANOI § Having seen a set of examples of different sized stacks, how would you write a program to print out the right set of moves? § Think recursively!
Solve a smaller problem
Solve a basic problem
Solve a smaller problem 19 def printMove(fr, to): print('move from ' + str(fr) + ' to ' + str(to)) def Towers(n, fr, to, spare): if n == 1: printMove(fr, to) else: Towers(n-1, fr, spare, to) Towers(1, fr, to, spare) Towers(n-1, spare, to, fr) 20 RECURSION WITH MULTIPLE BASE CASES § Fibonacci numbers
Leonardo of Pisa (aka Fibonacci) modeled the following challenge
Newborn pair of rabbits (one female, one male) are put in a pen
Rabbits mate at age of one month
Rabbits have a one month gestaSon period
Assume rabbits never die, that female always produces one new pair (one male, one female) every month from its second month on.
How many female rabbits are there at the end of one year? 21 Demo courtesy of Prof. Denny Freeman and Adam Hartz 22 Demo courtesy of Prof. Denny Freeman and Adam Hartz 23 Demo courtesy of Prof. Denny Freeman and Adam Hartz 24 Demo courtesy of Prof. Denny Freeman and Adam Hartz 25 Demo courtesy of Prof. Denny Freeman and Adam Hartz 26 Demo courtesy of Prof. Denny Freeman and Adam Hartz 27 Demo courtesy of Prof. Denny Freeman and Adam Hartz 28 29 Demo courtesy of Prof. Denny Freeman and Adam Hartz 30 Demo courtesy of Prof. Denny Freeman and Adam Hartz 31 FIBONACCI Ayer one month (call it 0) – 1 female Month Females Ayer second month – sSll 1 female (now 0 1 pregnant) 1 1 2 2 Ayer third month – two females, one pregnant, 3 3 one not 4 5 In general, females(n) = females(n-1) + 5 8 females(n-2) 6 13
Every female alive at month n-2 will produce one female in month n;
These can be added those alive in month n-1 to get total alive in month n 32 FIBONACCI § Base cases:
Females(0) = 1
Females(1) = 1 § Recursive case
Females(n) = Females(n-1) + Females(n-2) 33 FIBONACCI def fib(x): """assumes x an int >= 0 returns Fibonacci of x""” if x == 0 or x == 1: return 1 else: return fib(x-1) + fib(x-2) 34 RECURSION ON NONNUMERICS § how to check if a string of characters is a palindrome, i.e., reads the same forwards and backwards
“Able was I, ere I saw Elba” – avributed to Napoleon
“Are we not drawn onward, we few, drawn onward to new era?” – avributed to Anne Michaels Image courtesy of wikipedia, in the public domain. By Larth_Rasnal (Own work) [GFDL (https://www.gnu.org/licenses/fdl-1.3.en.html) or CC BY 3.0 (https://creativecommons.org/licenses/by/3.0)], via Wikimedia Commons. 35 SOLVING RECURSIVELY? § First, convert the string to just characters, by stripping out punctuaSon, and converSng upper case to lower case § Then
Base case: a string of length 0 or 1 is a palindrome
Recursive case:
If first character matches last character, then is a palindrome if middle secSon is a palindrome 36 EXAMPLE § ‘Able was I, ere I saw Elba’ à ‘ablewasiereisawleba’ § isPalindrome(‘ablewasiereisawleba’) is same as
‘a’ == ‘a’ and isPalindrome(‘blewasiereisawleb’) 37 def isPalindrome(s): def toChars(s): s = s.lower() ans = '' for c in s: if c in 'abcdefghijklmnopqrstuvwxyz': ans = ans + c return ans def isPal(s): if len(s) <= 1: return True else: return s[0] == s[-1] and isPal(s[1:-1]) return isPal(toChars(s)) 38 DIVIDE AND CONQUER § an example of a “divide and conquer” algorithm § solve a hard problem by breaking it into a set of subproblems such that:
sub-problems are easier to solve than the original
soluSons of the sub-problems can be combined to solve the original 39 DICTIONARIES 40 HOW TO STORE STUDENT INFO § so far, can store using separate lists for every info names = ['Ana', 'John', 'Denise', 'Katy'] grade = ['B', 'A+', 'A', 'A'] course = [2.00, 6.0001, 20.002, 9.01] § a separate list for each item § each list must have the same length § info stored across lists at same index, each index refers to info for a different person 41 HOW TO UPDATE/RETRIEVE STUDENT INFO def get_grade(student, name_list, grade_list, course_list): i = name_list.index(student) grade = grade_list[i] course = course_list[i] return (course, grade) § messy if have a lot of different info to keep track of § must maintain many lists and pass them as arguments § must always index using integers § must remember to change mulSple lists 42 A BETTER AND CLEANER WAY – A DICTIONARY § nice to index item of interest directly (not always int) § nice to use one data structure, no separate lists A list A dic0onary 0 Elem 1 Key 1 Val 1 1 Elem 2 Key 2 Val 2 2 Elem 3 Key 3 Val 3 3 Elem 4 Key 4 Val 4 … … … … 43 A PYTHON DICTIONARY § store pairs of data 'AnKae'y 1 V'aBl' 1
key 'DeniKesye 2' V'aAl' 2
value 'JohKeny' 3 'VAa+l 3' 'Katy…' 'A…' my_dict = {} grades = {'Ana':'B', 'John':'A+', 'Denise':'A', 'Katy':'A'} key1 val1 key2 val2 key3 val3 key4 val4 44 DICTIONARY LOOKUP § similar to indexing into a list 'Ana' 'B' § looks up the key 'Denise' 'A' § returns the value associated 'John' 'A+' with the key 'Katy' 'A' § if key isn’t found, get an error grades = {'Ana':'B', 'John':'A+', 'Denise':'A', 'Katy':'A'} grades['John'] à evaluates to 'A+' grades['Sylvan'] à gives a KeyError 45 DICTIONARY 'Ana' 'B' 'Denise' 'A' OPERATIONS 'John' 'A+' 'Katy' 'A' 'Sylvan' 'A' grades = {'Ana':'B', 'John':'A+', 'Denise':'A', 'Katy':'A'} § add an entry grades['Sylvan'] = 'A' § test if key in dicSonary 'John' in grades à returns True 'Daniel' in grades à returns False § delete entry del(grades['Ana']) 46 DICTIONARY 'Ana' 'B' 'Denise' 'A' OPERATIONS 'John' 'A+' 'Katy' 'A' grades = {'Ana':'B', 'John':'A+', 'Denise':'A', 'Katy':'A'} § get an iterable that acts like a tuple of all keys grades.keys() à returns ['Denise','Katy','John','Ana'] § get an iterable that acts like a tuple of all values grades.values() à returns ['A', 'A', 'A+', 'B'] 47 DICTIONARY KEYS and VALUES § values
any type (immutable and mutable)
can be duplicates
dicSonary values can be lists, even other dicSonaries! § keys
must be unique
immutable type (int, float, string, tuple,bool)
actually need an object that is hashable, but think of as immutable as all immutable types are hashable
careful with float type as a key § no order to keys or values! d = {4:{1:0}, (1,3):"twelve", 'const':[3.14,2.7,8.44]} 48 v s list dict § ordered sequence of § matches “keys” to elements “values” § look up elements by an § look up one item by integer index another item § indices have an order § no order is guaranteed § index is an integer § key can be any immutable type 49 EXAMPLE: 3 FUNCTIONS TO ANALYZE SONG LYRICS 1) create a frequency dic0onary mapping str:int 2) find word that occurs the most and how many Smes
use a list, in case there is more than one word
return a tuple (list,int) for (words_list, highest_freq) 3) find the words that occur at least X 0mes
let user choose “at least X Smes”, so allow as parameter
return a list of tuples, each tuple is a (list, int) containing the list of words ordered by their frequency
IDEA: From song dicSonary, find most frequent word. Delete most common word. Repeat. It works because you are mutaSng the song dicSonary. 50 CREATING A DICTIONARY def lyrics_to_frequencies(lyrics): myDict = {} for word in lyrics: if word in myDict: myDict[word] += 1 else: myDict[word] = 1 return myDict 51 USING THE DICTIONARY def most_common_words(freqs): values = freqs.values() best = max(values) words = [] for k in freqs: if freqs[k] == best: words.append(k) return (words, best) 52 LEVERAGING DICTIONARY PROPERTIES def words_often(freqs, minTimes): result = [] done = False while not done: temp = most_common_words(freqs) if temp[1] >= minTimes: result.append(temp) for w in temp[0]: del(freqs[w]) else: done = True return result print(words_often(beatles, 5)) 53 FIBONACCI RECURSIVE CODE def fib(n): if n == 1: return 1 elif n == 2: return 2 else: return fib(n-1) + fib(n-2) § two base cases § calls itself twice § this code is inefficient 54 INEFFICIENT FIBONACCI fib(n) = fib(n-1) + fib(n-2) fib(5) fib(4) fib(3) fib(3) fib(2) fib(2) fib(1) fib(2) fib(1) § recalcula0ng the same values many Smes! § could keep track of already calculated values 55 FIBONACCI WITH A DICTIONARY def fib_efficient(n, d): if n in d: return d[n] else: ans = fib_efficient(n-1, d) + fib_efficient(n-2, d) d[n] = ans return ans d = {1:1, 2:2} print(fib_efficient(6, d)) § do a lookup first in case already calculated the value § modify dic0onary as progress through funcSon calls 56 EFFICIENCY GAINS § Calling fib(34) results in 11,405,773 recursive calls to the procedure § Calling fib_efficient(34) results in 65 recursive calls to the procedure § Using dicSonaries to capture intermediate results can be very efficient § But note that this only works for procedures without side effects (i.e., the procedure will always produce the same result for a specific argument independent of any other computaSons between calls) 57 MIT OpenCourseWare https://ocw.mit.edu 6.0001 Introduction to Computer Science and Programming in Python Fall 2016 For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms.