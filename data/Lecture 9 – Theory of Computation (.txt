MIT 18.404 / 6.840 – Theory of Computation  
Lecture 4 – Context Free Grammars and Pushdown Automata  
(Sipser §2.2)

Last time:
- Finite automata → regular expressions
- Proving languages aren’t regular
- Context free grammars

Today:
- Context free grammars (CFGs) – definition
- Context free languages (CFLs)
- Pushdown automata (PDA)
- Converting CFGs to PDAs

---

Context Free Grammars (CFGs)

Example:
S → 0S1 | R  
R → ε

This grammar generates strings like:
0S1 → 00S11 → 00R11 → 0011

Explanation:
1. Write down the start variable.
2. Replace any variable using a rule.
3. Repeat until only terminals remain.
4. The resulting string is generated by the CFG.
5. The set of all such strings is the language of the CFG.

The CFG:
S → 0S1 | R  
R → ε  
Generates the language { 0ⁿ1ⁿ | n ≥ 0 }, which is context-free.

Formal Definition:
A CFG G is a 4-tuple (V, Σ, R, S)
- V: finite set of variables
- Σ: finite set of terminals
- R: finite set of rules, each of form A → w where A ∈ V and w ∈ (V ∪ Σ)*
- S: start variable

Notation:
α ⇒ β means α can be rewritten to β in one step  
α ⇒* β means α can be rewritten to β in zero or more steps

Language of CFG G:
L(G) = { w ∈ Σ* | S ⇒* w }

---

Check-in 4.1:
Which are valid CFGs?

90: B → 0B1 | ε  
91: S → 0S | S1  
B1 → 1B, R → RR, 0B → 0B

(a) 90 only  
(b) 91 only  
(c) Both 90 and 91  
(d) Neither

Answer: (a) 90 only (91 is invalid – left recursion without terminal base case)

---

Example CFG with arithmetic expressions:
E → E+T | T  
T → T×F | F  
F → (E) | a

This grammar generates strings like:
a+a×a

It respects operator precedence: × binds more tightly than +.

Ambiguity:
A grammar is ambiguous if a string has multiple distinct parse trees.

Example:
Grammar G1 (unambiguous):
E → E+T | T  
T → T×F | F  
F → (E) | a

Grammar G2 (ambiguous):
E → E+E | E×E | (E) | a

Both generate the same language but G2 is ambiguous.

---

Check-in 4.2:
How many reasonable meanings does this sentence have?

"The boy saw the girl with the mirror."

(a) 1  
(b) 2  
(c) 3 or more

Answer: (b) 2  
(1: The boy used the mirror. 2: The girl had the mirror.)

---

Pushdown Automata (PDA)

Like an NFA but with a stack.

Example PDA for L = { 0ⁿ1ⁿ | n ≥ 0 }:
1. Read 0s and push onto stack.
2. Read 1s and pop stack.
3. Accept if stack is empty at end of input.

Formal definition of a PDA:
A PDA is a 6-tuple (Q, Σ, Γ, δ, q0, F)
- Q: set of states
- Σ: input alphabet
- Γ: stack alphabet
- δ: transition function (Q × Σε × Γε → powerset(Q × Γε))
- q0: start state
- F: accept states

PDAs are **nondeterministic**.

---

Example: PDA for { wwᴿ | w ∈ {0,1}* }

1. Read and push symbols nondeterministically.
2. At some point, switch to popping and comparing.
3. Accept if match and stack is empty.

---

Converting CFGs to PDAs

Theorem: Every context-free language is recognized by some PDA.

Conversion idea:
- PDA starts by pushing the start variable onto stack.
- While stack not empty:
  - If top is a variable, nondeterministically apply a rule (push RHS).
  - If top is a terminal, pop and match with input.
- Accept if input is consumed and stack is empty.

Example CFG:
E → E+T | T  
T → T×F | F  
F → (E) | a

For string a+a×a:
PDA will mimic the derivation using stack symbols and input matching.

---

Theorem:
A language is context-free iff it is recognized by some PDA.

---

Check-in 4.3:
Is every regular language also a context-free language?

(a) Yes  
(b) No  
(c) Not sure

Answer: (a) Yes

Regular languages ⊂ Context-free languages

---

Recap:
- Defined CFGs and CFLs
- Defined PDAs
- Converted CFGs to PDAs

MIT OpenCourseWare  
https://ocw.mit.edu  
18.404J / 6.840J – Theory of Computation  
Fall 2020
